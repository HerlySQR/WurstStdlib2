package Destructable
import NoWurst
import Wurstunit
import Annotations
import initlater Unit
import Item
import Rect
import initlater ClosureForGroups

public function createDestructable(int id, vec3 pos, angle direction, real scale, int variation) returns destructable
	return createDestructable(id, pos.toVec2(), direction, scale, variation)

public function createDestructable(int id, vec2 pos, angle direction, real scale, int variation) returns destructable
	return CreateDestructable(id, pos.x, pos.y, direction.degrees(), scale, variation)

public function destructable.getPos() returns vec2
	return vec2(this.getX(), this.getY())

public function destructable.getX() returns real
	return GetDestructableX(this)

public function destructable.getY() returns real
	return GetDestructableY(this)

public function destructable.kill()
	KillDestructable(this)

public function destructable.getTypeId() returns int
	return GetDestructableTypeId(this)

public function destructable.setAnimation(string anim)
	SetDestructableAnimation(this, anim)

public function destructable.remove()
	RemoveDestructable(this)

public function destructable.setInvulnerable(bool flag)
	SetDestructableInvulnerable(this, flag)

public function destructable.isInvulnerable() returns bool
	return IsDestructableInvulnerable(this)

@deprecated("Use .isInvulnerable instead")
public function destructable.getInvulnerable() returns bool
	return IsDestructableInvulnerable(this)

public function destructable.setLife(real life)
	SetDestructableLife(this, life)

public function destructable.getLife() returns real
	return GetDestructableLife(this)

public function destructable.setMaxLife(real max)
	SetDestructableMaxLife(this, max)

public function destructable.getMaxLife() returns real
	return GetDestructableMaxLife(this)

public function destructable.restoreLife(real life, boolean birth)
	DestructableRestoreLife(this, life, birth)

public function destructable.queueAnimation(string anim)
	QueueDestructableAnimation(this, anim)

public function destructable.setAnimationSpeed(real speedFactor)
	SetDestructableAnimationSpeed(this, speedFactor)

public function destructable.show(bool flag)
	ShowDestructable(this, flag)

public function destructable.getOccluderHeight() returns real
	return GetDestructableOccluderHeight(this)

public function destructable.setOccluderHeight(real height)
	SetDestructableOccluderHeight(this, height)

public function destructable.getName() returns string
	return GetDestructableName(this)

// Extensions

/** Tuple wrapper for destructable gates API */
public tuple gate(destructable killable)

/** Opens a destructable gate (only if is not destroyed)*/
public function gate.open()
	if (GetDestructableLife(this.killable) > 0)
		KillDestructable(this.killable)
		SetDestructableAnimation(this.killable, "death alternate")

/** Closes a destructable gate */
public function gate.close()
	this.open()
	DestructableRestoreLife(this.killable, GetDestructableMaxLife(this.killable), true)
	SetDestructableAnimation(this.killable, "stand")

/** Destroys a destructable gate */
public function gate.kill()
	this.open()
	SetDestructableAnimation(this.killable, "death")

/** Sets the gate's open/close state */
public function gate.setOpen(bool flag)
	if flag
		this.open()
	else
		this.close()

/** Tuple wrapper for destructable elevator API */
public tuple elevator(destructable elevatable)

constant ELEVATOR_HEIGHT_MIN = 1
constant ELEVATOR_HEIGHT_MAX = 3

/** Moves a destructable elevator one step up */
public function elevator.up()
	this.setHeight(this.getHeight() + 1)

/** Moves a destructable elevator one step down */
public function elevator.down()
	this.setHeight(this.getHeight() - 1)

/** Moves a destructable elevator to given height */
public function elevator.elevatorSetHeight(int height)
	this.setHeight(height)

/** Get a destructable elevator height */
public function elevator.getHeight() returns int
	let height = ELEVATOR_HEIGHT_MIN + (this.elevatable.getOccluderHeight() / bj_CLIFFHEIGHT).toInt()
	return height < ELEVATOR_HEIGHT_MIN or height > ELEVATOR_HEIGHT_MAX ? ELEVATOR_HEIGHT_MIN : height

/** Returns elevator adjusted height based on given bounds */
public function isElevatorHeightInBounds(int height) returns bool
	return height >= ELEVATOR_HEIGHT_MIN and height <= ELEVATOR_HEIGHT_MAX
	
/** Returns elevator adjusted height based on given bounds */
public function getElevatorHeightBound(int height) returns int
	return height < ELEVATOR_HEIGHT_MIN ? ELEVATOR_HEIGHT_MIN : (height > ELEVATOR_HEIGHT_MAX ? ELEVATOR_HEIGHT_MAX : height)

/** Set elevator height to given value. */
public function elevator.setHeight(int height)
	let oldHeight = this.getHeight()
	let newHeight = getElevatorHeightBound(height)
	this.elevatable.setOccluderHeight(bj_CLIFFHEIGHT * (newHeight - ELEVATOR_HEIGHT_MIN))

	var animationInstant = "stand"
	var animationQueue = "stand"
	switch (newHeight)
		case ELEVATOR_HEIGHT_MIN
			animationInstant = oldHeight == 2 ? "birth" : (oldHeight == ELEVATOR_HEIGHT_MAX ? "birth third" : animationInstant)
		case ELEVATOR_HEIGHT_MAX
			animationInstant = oldHeight == ELEVATOR_HEIGHT_MIN ? "death third" : (oldHeight == 2 ? "death second" : animationInstant + " third")
			animationQueue += " third"
		default
			animationInstant = oldHeight == ELEVATOR_HEIGHT_MIN ? "death" : (oldHeight == ELEVATOR_HEIGHT_MAX ? "birth second" : animationInstant + " second")
			animationQueue += " second"

	this.elevatable.setAnimation(animationInstant)
	if newHeight != oldHeight
		this.elevatable.queueAnimation(animationQueue)

public enum EWType
	EAST
    NORTH
    SOUTH
    WEST
    ALL

function rect.nudgeObjects()
    forUnitsInRect(this, u -> u.setPos(u.getPos()))
    EnumItemsInRect(this, null, () -> GetEnumItem().setPos(GetEnumItem().getPos()))

destructable blocker

function changeWallBlocker(real x, real y, real facing, boolean open)
    let findThreshold = 32
    let nudgeLength   = 4.25 * bj_CELLWIDTH
    let nudgeWidth    = 1.25 * bj_CELLWIDTH
    // Search for the pathing blocker within the general area.
    let r = Rect(x - findThreshold, y - findThreshold, x + findThreshold, y + findThreshold)
    blocker = null
    EnumDestructablesInRect(r, null, () -> begin
        blocker = GetEnumDestructable()
    end)
    r.remove()

    // Ensure that the blocker exists.
    if (blocker == null)
        blocker = CreateDeadDestructable(bj_ELEVATOR_BLOCKER_CODE, x, y, facing, 1, 0)
    else if blocker.getTypeId() != bj_ELEVATOR_BLOCKER_CODE
        // If a different destructible exists in the blocker's spot, ignore
        // the request.  (Two destructibles cannot occupy the same location
        // on the map, so we cannot create an elevator blocker here.)
        return

    if open
        // Ensure that the blocker is dead.
        if blocker.getLife() > 0
            blocker.kill()
    else
        // Ensure that the blocker is alive.
        if blocker.getLife() <= 0
            DestructableRestoreLife(blocker, GetDestructableMaxLife(blocker), false)

        // Nudge any objects standing in the blocker's way.
        if facing == 0
            Rect(x - nudgeWidth/2, y - nudgeLength/2, x + nudgeWidth/2, y + nudgeLength/2)
                ..nudgeObjects()
                ..remove()
        else if facing == 90
            Rect(x - nudgeLength/2, y - nudgeWidth/2, x + nudgeLength/2, y + nudgeWidth/2)
                ..nudgeObjects()
                ..remove()

destructable elevatorNeighbor

function nearbyElevatorExists(real x, real y) returns boolean
    let findThreshold = 32
    // If another elevator is overlapping this one, ignore the wall.
    let r = Rect(x - findThreshold, y - findThreshold, x + findThreshold, y + findThreshold)
    elevatorNeighbor = null
    EnumDestructablesInRect(r, null, () -> begin
        let dType = GetEnumDestructable().getTypeId()
        if dType == bj_ELEVATOR_CODE01 or dType == bj_ELEVATOR_CODE02
            elevatorNeighbor = GetEnumDestructable()
    end)
    r.remove()
    return elevatorNeighbor != null

/** Adds wall blockers to the elevator in the specified directions*/
public function elevator.changeWalls(boolean open, EWType walls)
    let x = this.elevatable.getX()
    let y = this.elevatable.getY()
    let distToBlocker = 192
    let distToNeighbor = 256

    let b = [
        walls == ALL,
        walls == EAST,
        walls == NORTH,
        walls == SOUTH,
        walls == WEST
    ]

    if b[0] or b[1]
        if not nearbyElevatorExists(x + distToNeighbor, y)
            changeWallBlocker(x + distToBlocker, y, 0, open)

    if b[0] or b[2]
        if not nearbyElevatorExists(x, y + distToNeighbor)
            changeWallBlocker(x, y + distToBlocker, 90, open)

    if b[0] or b[3]
        if not nearbyElevatorExists(x, y - distToNeighbor)
            changeWallBlocker(x, y - distToBlocker, 90, open)

    if b[0] or b[4]
        if not nearbyElevatorExists(x - distToNeighbor, y)
            changeWallBlocker(x - distToBlocker, y, 0, open)

@Test function testDestructables()
	let destr = createDestructable(0, ZERO2, 0 .fromDeg(), 1, -1)
	destr.getX().assertEquals(0.)